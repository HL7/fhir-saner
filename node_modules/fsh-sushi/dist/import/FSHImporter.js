"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const FSHDocument_1 = require("./FSHDocument");
const FSHErrorListener_1 = require("./FSHErrorListener");
const FSHVisitor_1 = require("./generated/FSHVisitor");
const FSHLexer_1 = require("./generated/FSHLexer");
const FSHParser_1 = require("./generated/FSHParser");
const fshtypes_1 = require("../fshtypes");
const rules_1 = require("../fshtypes/rules");
const antlr4_1 = require("antlr4");
const FSHLogger_1 = require("../utils/FSHLogger");
const Tree_1 = require("antlr4/tree/Tree");
const errors_1 = require("../errors");
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const upperFirst_1 = __importDefault(require("lodash/upperFirst"));
var SdMetadataKey;
(function (SdMetadataKey) {
    SdMetadataKey["Id"] = "Id";
    SdMetadataKey["Parent"] = "Parent";
    SdMetadataKey["Title"] = "Title";
    SdMetadataKey["Description"] = "Description";
    SdMetadataKey["Mixins"] = "Mixins";
    SdMetadataKey["Unknown"] = "Unknown";
})(SdMetadataKey || (SdMetadataKey = {}));
var InstanceMetadataKey;
(function (InstanceMetadataKey) {
    InstanceMetadataKey["InstanceOf"] = "InstanceOf";
    InstanceMetadataKey["Title"] = "Title";
    InstanceMetadataKey["Description"] = "Description";
    InstanceMetadataKey["Usage"] = "Usage";
    InstanceMetadataKey["Mixins"] = "Mixins";
    InstanceMetadataKey["Unknown"] = "Unknown";
})(InstanceMetadataKey || (InstanceMetadataKey = {}));
var VsMetadataKey;
(function (VsMetadataKey) {
    VsMetadataKey["Id"] = "Id";
    VsMetadataKey["Title"] = "Title";
    VsMetadataKey["Description"] = "Description";
    VsMetadataKey["Unknown"] = "Unknown";
})(VsMetadataKey || (VsMetadataKey = {}));
var CsMetadataKey;
(function (CsMetadataKey) {
    CsMetadataKey["Id"] = "Id";
    CsMetadataKey["Title"] = "Title";
    CsMetadataKey["Description"] = "Description";
    CsMetadataKey["Unknown"] = "Unknown";
})(CsMetadataKey || (CsMetadataKey = {}));
var InvariantMetadataKey;
(function (InvariantMetadataKey) {
    InvariantMetadataKey["Description"] = "Description";
    InvariantMetadataKey["Expression"] = "Expression";
    InvariantMetadataKey["XPath"] = "XPath";
    InvariantMetadataKey["Severity"] = "Severity";
    InvariantMetadataKey["Unknown"] = "Unknown";
})(InvariantMetadataKey || (InvariantMetadataKey = {}));
var MappingMetadataKey;
(function (MappingMetadataKey) {
    MappingMetadataKey["Id"] = "Id";
    MappingMetadataKey["Source"] = "Source";
    MappingMetadataKey["Target"] = "Target";
    MappingMetadataKey["Description"] = "Description";
    MappingMetadataKey["Title"] = "Title";
    MappingMetadataKey["Unknown"] = "Unknown";
})(MappingMetadataKey || (MappingMetadataKey = {}));
var Flag;
(function (Flag) {
    Flag[Flag["MustSupport"] = 0] = "MustSupport";
    Flag[Flag["Summary"] = 1] = "Summary";
    Flag[Flag["Modifier"] = 2] = "Modifier";
    Flag[Flag["TrialUse"] = 3] = "TrialUse";
    Flag[Flag["Normative"] = 4] = "Normative";
    Flag[Flag["Draft"] = 5] = "Draft";
    Flag[Flag["Unknown"] = 6] = "Unknown";
})(Flag || (Flag = {}));
/**
 * FSHImporter handles the parsing of FSH documents, constructing the data into FSH types.
 * FSHImporter uses a visitor pattern approach with some accomodations due to the ANTLR4
 * implementation and TypeScript requirements.  For example, the `accept` functions that
 * each `ctx` has cannot be used because their signatures return `void` by default. Instead,
 * we must call the explicit visitX functions.
 */
class FSHImporter extends FSHVisitor_1.FSHVisitor {
    constructor() {
        super();
    }
    import(rawFSHes) {
        this.allAliases = new Map();
        const docs = [];
        const contexts = [];
        // Preprocess the FSH files
        rawFSHes.forEach(rawFSH => {
            // Create and store doc for main import process
            const doc = new FSHDocument_1.FSHDocument(rawFSH.path);
            docs.push(doc);
            // Create and store context for main import process
            // We are appending a newline to the file content if there is not one there already.
            // This is being done because we discovered a syntax error that occurs if a comments
            // ends a file, and there is no newline after it. Comments are only tokenized in our
            // grammar if a newline follows it. In order to prevent this error from occurring,
            // we add a newline to the content before we parse it so comments at EOF can be tokenized.
            const content = rawFSH.content.endsWith('\n') ? rawFSH.content : rawFSH.content + '\n';
            const ctx = this.parseDoc(content, rawFSH.path);
            contexts.push(ctx);
            // Collect the aliases and store in global map
            ctx.entity().forEach(e => {
                var _a;
                if (e.alias()) {
                    const [name, value] = e
                        .alias()
                        .SEQUENCE()
                        .map(s => s.getText());
                    if (this.allAliases.has(name) && this.allAliases.get(name) !== value) {
                        FSHLogger_1.logger.error(`Alias ${name} cannot be redefined to ${value}; it is already defined as ${this.allAliases.get(name)}.`, { file: (_a = doc.file, (_a !== null && _a !== void 0 ? _a : '')), location: this.extractStartStop(e.alias()) });
                        // don't set it -- just keep the original definition
                    }
                    else {
                        this.allAliases.set(name, value);
                        doc.aliases.set(name, value);
                    }
                }
            });
        });
        FSHLogger_1.logger.info(`Preprocessed ${docs.length} documents with ${this.allAliases.size} aliases.`);
        // Now do the main import
        contexts.forEach((context, index) => {
            var _a;
            this.currentDoc = docs[index];
            this.currentFile = (_a = this.currentDoc.file, (_a !== null && _a !== void 0 ? _a : ''));
            this.visitDoc(context);
            this.currentDoc = null;
            this.currentFile = null;
        });
        let [definitions, instances] = [0, 0];
        docs.forEach(doc => {
            definitions +=
                doc.codeSystems.size + doc.extensions.size + doc.profiles.size + doc.valueSets.size;
            instances += doc.instances.size;
        });
        FSHLogger_1.logger.info(`Imported ${definitions} definitions and ${instances} instances.`);
        return docs;
    }
    visitDoc(ctx) {
        ctx.entity().forEach(e => {
            try {
                this.visitEntity(e);
            }
            catch (err) {
                const sourceInfo = { location: this.extractStartStop(e), file: this.currentFile };
                FSHLogger_1.logger.error(`Error in parsing: ${err.message}`, sourceInfo);
            }
        });
    }
    visitEntity(ctx) {
        if (ctx.profile()) {
            this.visitProfile(ctx.profile());
        }
        if (ctx.extension()) {
            this.visitExtension(ctx.extension());
        }
        if (ctx.instance()) {
            this.visitInstance(ctx.instance());
        }
        if (ctx.valueSet()) {
            this.visitValueSet(ctx.valueSet());
        }
        if (ctx.codeSystem()) {
            this.visitCodeSystem(ctx.codeSystem());
        }
        if (ctx.invariant()) {
            this.visitInvariant(ctx.invariant());
        }
        if (ctx.ruleSet()) {
            this.visitRuleSet(ctx.ruleSet());
        }
        if (ctx.mapping()) {
            this.visitMapping(ctx.mapping());
        }
    }
    visitProfile(ctx) {
        const profile = new fshtypes_1.Profile(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseProfileOrExtension(profile, ctx.sdMetadata(), ctx.sdRule());
        this.currentDoc.profiles.set(profile.name, profile);
    }
    visitExtension(ctx) {
        const extension = new fshtypes_1.Extension(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseProfileOrExtension(extension, ctx.sdMetadata(), ctx.sdRule());
        this.currentDoc.extensions.set(extension.name, extension);
    }
    parseProfileOrExtension(def, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(sdMeta => (Object.assign(Object.assign({}, this.visitSdMetadata(sdMeta)), { context: sdMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === SdMetadataKey.Id) {
                def.id = pair.value;
            }
            else if (pair.key === SdMetadataKey.Parent) {
                def.parent = pair.value;
            }
            else if (pair.key === SdMetadataKey.Title) {
                def.title = pair.value;
            }
            else if (pair.key === SdMetadataKey.Description) {
                def.description = pair.value;
            }
            else if (pair.key === SdMetadataKey.Mixins) {
                def.mixins = pair.value;
            }
        });
        ruleCtx.forEach(sdRule => {
            def.rules.push(...this.visitSdRule(sdRule));
        });
    }
    visitInstance(ctx) {
        const instance = new fshtypes_1.Instance(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        try {
            this.parseInstance(instance, ctx.instanceMetadata(), ctx.fixedValueRule());
            this.currentDoc.instances.set(instance.name, instance);
        }
        catch (e) {
            FSHLogger_1.logger.error(e.message, instance.sourceInfo);
        }
    }
    parseInstance(instance, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(instanceMetadata => (Object.assign(Object.assign({}, this.visitInstanceMetadata(instanceMetadata)), { context: instanceMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === InstanceMetadataKey.InstanceOf) {
                instance.instanceOf = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Title) {
                instance.title = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Description) {
                instance.description = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Usage) {
                instance.usage = pair.value;
            }
            else if (pair.key === InstanceMetadataKey.Mixins) {
                instance.mixins = pair.value;
            }
        });
        if (!instance.instanceOf) {
            throw new errors_1.RequiredMetadataError('InstanceOf', 'Instance', instance.name);
        }
        ruleCtx.forEach(fvRule => {
            instance.rules.push(this.visitFixedValueRule(fvRule));
        });
    }
    visitValueSet(ctx) {
        const valueSet = new fshtypes_1.FshValueSet(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseValueSet(valueSet, ctx.vsMetadata(), ctx.vsComponent(), ctx.caretValueRule());
        this.currentDoc.valueSets.set(valueSet.name, valueSet);
    }
    parseValueSet(valueSet, metaCtx = [], componentCtx = [], caretValueRuleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(vsMetadata => (Object.assign(Object.assign({}, this.visitVsMetadata(vsMetadata)), { context: vsMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === VsMetadataKey.Id) {
                valueSet.id = pair.value;
            }
            else if (pair.key === VsMetadataKey.Title) {
                valueSet.title = pair.value;
            }
            else if (pair.key === VsMetadataKey.Description) {
                valueSet.description = pair.value;
            }
        });
        componentCtx
            .map(vsComponentCtx => this.visitVsComponent(vsComponentCtx))
            .forEach(vsComponent => {
            // if vsComponent is a concept component,
            // we may be able to merge its concepts into an existing concept component.
            if (vsComponent instanceof fshtypes_1.ValueSetConceptComponent) {
                const matchedComponent = valueSet.components.find(existingComponent => {
                    return (existingComponent instanceof fshtypes_1.ValueSetConceptComponent &&
                        vsComponent.inclusion == existingComponent.inclusion &&
                        vsComponent.from.system == existingComponent.from.system &&
                        isEqual_1.default(sortBy_1.default(vsComponent.from.valueSets), sortBy_1.default(existingComponent.from.valueSets)));
                });
                if (matchedComponent) {
                    matchedComponent.concepts.push(...vsComponent.concepts);
                }
                else {
                    valueSet.components.push(vsComponent);
                }
            }
            else {
                valueSet.components.push(vsComponent);
            }
        });
        caretValueRuleCtx.forEach(caretValueRule => {
            const rule = this.visitCaretValueRule(caretValueRule);
            if (rule.path) {
                FSHLogger_1.logger.error('Caret rule on ValueSet cannot contain path before ^, skipping rule.', rule.sourceInfo);
            }
            else {
                valueSet.rules.push(this.visitCaretValueRule(caretValueRule));
            }
        });
    }
    visitCodeSystem(ctx) {
        const codeSystem = new fshtypes_1.FshCodeSystem(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseCodeSystem(codeSystem, ctx.csMetadata(), ctx.concept(), ctx.caretValueRule());
        this.currentDoc.codeSystems.set(codeSystem.name, codeSystem);
    }
    parseCodeSystem(codeSystem, metaCtx = [], conceptCtx = [], caretValueRuleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(csMetadata => (Object.assign(Object.assign({}, this.visitCsMetadata(csMetadata)), { context: csMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === CsMetadataKey.Id) {
                codeSystem.id = pair.value;
            }
            else if (pair.key === CsMetadataKey.Title) {
                codeSystem.title = pair.value;
            }
            else if (pair.key === CsMetadataKey.Description) {
                codeSystem.description = pair.value;
            }
        });
        conceptCtx.forEach(conceptCtx => {
            const newConcept = this.visitConcept(conceptCtx);
            try {
                codeSystem.addConcept(newConcept);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, newConcept.sourceInfo);
            }
        });
        caretValueRuleCtx.forEach(caretValueRule => {
            const rule = this.visitCaretValueRule(caretValueRule);
            if (rule.path) {
                FSHLogger_1.logger.error('Caret rule on CodeSystem cannot contain path before ^, skipping rule.', rule.sourceInfo);
            }
            else {
                codeSystem.rules.push(this.visitCaretValueRule(caretValueRule));
            }
        });
    }
    visitInvariant(ctx) {
        const invariant = new fshtypes_1.Invariant(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseInvariant(invariant, ctx.invariantMetadata());
        if (invariant.description == null) {
            FSHLogger_1.logger.error(`Invariant ${invariant.name} must have a Description.`, invariant.sourceInfo);
        }
        if (invariant.severity == null) {
            FSHLogger_1.logger.error(`Invariant ${invariant.name} must have a Severity.`, invariant.sourceInfo);
        }
        this.currentDoc.invariants.set(invariant.name, invariant);
    }
    parseInvariant(invariant, metaCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(invariantMetadata => (Object.assign(Object.assign({}, this.visitInvariantMetadata(invariantMetadata)), { context: invariantMetadata })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === InvariantMetadataKey.Description) {
                invariant.description = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.Expression) {
                invariant.expression = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.Severity) {
                invariant.severity = pair.value;
            }
            else if (pair.key === InvariantMetadataKey.XPath) {
                invariant.xpath = pair.value;
            }
        });
    }
    visitRuleSet(ctx) {
        const ruleSet = new fshtypes_1.RuleSet(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseRuleSet(ruleSet, ctx.sdRule());
        this.currentDoc.ruleSets.set(ruleSet.name, ruleSet);
    }
    parseRuleSet(ruleSet, rules) {
        rules.forEach(sdRule => {
            ruleSet.rules.push(...this.visitSdRule(sdRule));
        });
    }
    visitMapping(ctx) {
        const mapping = new fshtypes_1.Mapping(ctx.SEQUENCE().getText())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        this.parseMapping(mapping, ctx.mappingMetadata(), ctx.mappingRule());
        this.currentDoc.mappings.set(mapping.name, mapping);
    }
    parseMapping(mapping, metaCtx = [], ruleCtx = []) {
        const seenPairs = new Map();
        metaCtx
            .map(mapMeta => (Object.assign(Object.assign({}, this.visitMappingMetadata(mapMeta)), { context: mapMeta })))
            .forEach(pair => {
            if (seenPairs.has(pair.key)) {
                FSHLogger_1.logger.error(`Metadata field '${pair.key}' already declared with value '${seenPairs.get(pair.key)}'.`, { file: this.currentFile, location: this.extractStartStop(pair.context) });
                return;
            }
            seenPairs.set(pair.key, pair.value);
            if (pair.key === MappingMetadataKey.Id) {
                mapping.id = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Source) {
                mapping.source = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Target) {
                mapping.target = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Description) {
                mapping.description = pair.value;
            }
            else if (pair.key === MappingMetadataKey.Title) {
                mapping.title = pair.value;
            }
        });
        ruleCtx.forEach(mappingRule => {
            mapping.rules.push(this.visitMappingRule(mappingRule));
        });
    }
    visitSdMetadata(ctx) {
        if (ctx.id()) {
            return { key: SdMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.parent()) {
            return { key: SdMetadataKey.Parent, value: this.visitParent(ctx.parent()) };
        }
        else if (ctx.title()) {
            return { key: SdMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: SdMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        else if (ctx.mixins()) {
            return { key: SdMetadataKey.Mixins, value: this.visitMixins(ctx.mixins()) };
        }
        return { key: SdMetadataKey.Unknown, value: ctx.getText() };
    }
    visitInstanceMetadata(ctx) {
        if (ctx.instanceOf()) {
            return { key: InstanceMetadataKey.InstanceOf, value: this.visitInstanceOf(ctx.instanceOf()) };
        }
        else if (ctx.title()) {
            return { key: InstanceMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return {
                key: InstanceMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.usage()) {
            return {
                key: InstanceMetadataKey.Usage,
                value: this.visitUsage(ctx.usage())
            };
        }
        else if (ctx.mixins()) {
            return { key: InstanceMetadataKey.Mixins, value: this.visitMixins(ctx.mixins()) };
        }
        return { key: InstanceMetadataKey.Unknown, value: ctx.getText() };
    }
    visitVsMetadata(ctx) {
        if (ctx.id()) {
            return { key: VsMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.title()) {
            return { key: VsMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: VsMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: VsMetadataKey.Unknown, value: ctx.getText() };
    }
    visitCsMetadata(ctx) {
        if (ctx.id()) {
            return { key: CsMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.title()) {
            return { key: CsMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        else if (ctx.description()) {
            return { key: CsMetadataKey.Description, value: this.visitDescription(ctx.description()) };
        }
        return { key: CsMetadataKey.Unknown, value: ctx.getText() };
    }
    visitInvariantMetadata(ctx) {
        if (ctx.description()) {
            return {
                key: InvariantMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.expression()) {
            return {
                key: InvariantMetadataKey.Expression,
                value: this.visitExpression(ctx.expression())
            };
        }
        else if (ctx.xpath()) {
            return {
                key: InvariantMetadataKey.XPath,
                value: this.visitXpath(ctx.xpath())
            };
        }
        else if (ctx.severity()) {
            return {
                key: InvariantMetadataKey.Severity,
                value: this.visitSeverity(ctx.severity())
            };
        }
        return {
            key: InvariantMetadataKey.Unknown,
            value: ctx.getText()
        };
    }
    visitMappingMetadata(ctx) {
        if (ctx.id()) {
            return { key: MappingMetadataKey.Id, value: this.visitId(ctx.id()) };
        }
        else if (ctx.source()) {
            return { key: MappingMetadataKey.Source, value: this.visitSource(ctx.source()) };
        }
        else if (ctx.target()) {
            return { key: MappingMetadataKey.Target, value: this.visitTarget(ctx.target()) };
        }
        else if (ctx.description()) {
            return {
                key: MappingMetadataKey.Description,
                value: this.visitDescription(ctx.description())
            };
        }
        else if (ctx.title()) {
            return { key: MappingMetadataKey.Title, value: this.visitTitle(ctx.title()) };
        }
        return { key: MappingMetadataKey.Unknown, value: ctx.getText() };
    }
    visitId(ctx) {
        return ctx.SEQUENCE().getText();
    }
    visitParent(ctx) {
        return this.aliasAwareValue(ctx.SEQUENCE());
    }
    visitTitle(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitDescription(ctx) {
        if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        // it must be a multiline string
        return this.extractMultilineString(ctx.MULTILINE_STRING());
    }
    visitInstanceOf(ctx) {
        return this.aliasAwareValue(ctx.SEQUENCE());
    }
    visitMixins(ctx) {
        if (ctx.COMMA_DELIMITED_SEQUENCES()) {
            let mixins = ctx
                .COMMA_DELIMITED_SEQUENCES()
                .getText()
                .split(/\s*,\s*/);
            mixins = mixins.filter((m, i) => {
                const duplicated = mixins.indexOf(m) !== i;
                if (duplicated) {
                    FSHLogger_1.logger.warn(`Detected duplicated Mixin: ${m}. Ignoring duplicates.`, {
                        location: this.extractStartStop(ctx),
                        file: this.currentFile
                    });
                }
                return !duplicated;
            });
            return mixins;
        }
        else {
            return [ctx.SEQUENCE().getText()];
        }
    }
    visitUsage(ctx) {
        var _a;
        const usageConcept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx.CODE()))
            .withFile(this.currentFile);
        if (((_a = usageConcept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            FSHLogger_1.logger.warn('Do not specify a system for instance Usage.', usageConcept.sourceInfo);
        }
        let usage = upperFirst_1.default(usageConcept.code);
        if (!fshtypes_1.isInstanceUsage(usage)) {
            FSHLogger_1.logger.error('Invalid Usage. Supported usage codes are "#example", "#definition", and "#inline". Instance will be treated as an example.', usageConcept.sourceInfo);
            usage = 'Example';
        }
        return usage;
    }
    visitExpression(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitXpath(ctx) {
        return this.extractString(ctx.STRING());
    }
    visitSeverity(ctx) {
        var _a;
        const concept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx.CODE()))
            .withFile(this.currentFile);
        if (((_a = concept.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            FSHLogger_1.logger.warn('Do not specify a system for invariant severity.', concept.sourceInfo);
        }
        if (concept.code != 'error' && concept.code != 'warning') {
            FSHLogger_1.logger.error('Invalid invariant severity code: code must be "#error" or "#warning".', concept.sourceInfo);
        }
        return concept;
    }
    visitSource(ctx) {
        return this.aliasAwareValue(ctx.SEQUENCE());
    }
    visitTarget(ctx) {
        return this.extractString(ctx.STRING());
    }
    parseCodeLexeme(conceptText, parentCtx) {
        const splitPoint = conceptText.match(/(^|[^\\])(\\\\)*#/);
        let system, code;
        if (splitPoint == null) {
            system = '';
            code = conceptText.slice(1);
        }
        else {
            system = conceptText.slice(0, splitPoint.index) + splitPoint[0].slice(0, -1);
            code = conceptText.slice(splitPoint.index + splitPoint[0].length);
        }
        system = system.replace(/\\\\/g, '\\').replace(/\\#/g, '#');
        if (code.startsWith('"')) {
            code = code
                .slice(1, code.length - 1)
                .replace(/\\\\/g, '\\')
                .replace(/\\"/g, '"');
        }
        const concept = new fshtypes_1.FshCode(code);
        if (system.length > 0) {
            concept.system = this.aliasAwareValue(parentCtx, system);
        }
        return concept;
    }
    visitSdRule(ctx) {
        if (ctx.cardRule()) {
            return this.visitCardRule(ctx.cardRule());
        }
        else if (ctx.flagRule()) {
            return this.visitFlagRule(ctx.flagRule());
        }
        else if (ctx.valueSetRule()) {
            return [this.visitValueSetRule(ctx.valueSetRule())];
        }
        else if (ctx.fixedValueRule()) {
            const rule = this.visitFixedValueRule(ctx.fixedValueRule());
            if (rule.isResource) {
                const sourceInfo = { location: this.extractStartStop(ctx), file: this.currentFile };
                FSHLogger_1.logger.error('Resources cannot be added inline to a Profile or Extension, skipping rule.', sourceInfo);
                return [];
            }
            else {
                return [rule];
            }
        }
        else if (ctx.onlyRule()) {
            return [this.visitOnlyRule(ctx.onlyRule())];
        }
        else if (ctx.containsRule()) {
            return this.visitContainsRule(ctx.containsRule());
        }
        else if (ctx.caretValueRule()) {
            return [this.visitCaretValueRule(ctx.caretValueRule())];
        }
        else if (ctx.obeysRule()) {
            return this.visitObeysRule(ctx.obeysRule());
        }
        FSHLogger_1.logger.warn(`Unsupported rule: ${ctx.getText()}`, {
            file: this.currentFile,
            location: this.extractStartStop(ctx)
        });
        return [];
    }
    visitPath(ctx) {
        if (ctx.KW_SYSTEM()) {
            return ctx.KW_SYSTEM().getText();
        }
        return ctx.SEQUENCE().getText();
    }
    visitCaretPath(ctx) {
        return ctx.CARET_SEQUENCE().getText();
    }
    visitPaths(ctx) {
        return ctx
            .COMMA_DELIMITED_SEQUENCES()
            .getText()
            .split(/\s*,\s*/);
    }
    visitCardRule(ctx) {
        const rules = [];
        const cardRule = new rules_1.CardRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        const card = this.parseCard(ctx.CARD().getText(), cardRule);
        cardRule.min = card.min;
        cardRule.max = card.max;
        rules.push(cardRule);
        if (ctx.flag() && ctx.flag().length > 0) {
            const flagRule = new rules_1.FlagRule(cardRule.path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            this.parseFlags(flagRule, ctx.flag());
            rules.push(flagRule);
        }
        return rules;
    }
    parseCard(card, rule) {
        const parts = card.split('..', 2);
        if (parts[0] === '' && parts[1] === '') {
            FSHLogger_1.logger.error(`Neither side of the cardinality was specified on path "${rule.path}". A min, max, or both need to be specified.`, rule.sourceInfo);
        }
        return {
            min: parseInt(parts[0]),
            max: parts[1]
        };
    }
    visitFlagRule(ctx) {
        let paths;
        if (ctx.path()) {
            paths = [this.visitPath(ctx.path())];
        }
        else if (ctx.paths()) {
            paths = this.visitPaths(ctx.paths());
        }
        return paths.map(path => {
            const flagRule = new rules_1.FlagRule(path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            this.parseFlags(flagRule, ctx.flag());
            return flagRule;
        });
    }
    parseFlags(flagRule, flagContext) {
        const flags = flagContext.map(f => this.visitFlag(f));
        if (flags.includes(Flag.MustSupport)) {
            flagRule.mustSupport = true;
        }
        if (flags.includes(Flag.Summary)) {
            flagRule.summary = true;
        }
        if (flags.includes(Flag.Modifier)) {
            flagRule.modifier = true;
        }
        if (flags.includes(Flag.TrialUse)) {
            flagRule.trialUse = true;
        }
        if (flags.includes(Flag.Normative)) {
            flagRule.normative = true;
        }
        if (flags.includes(Flag.Draft)) {
            flagRule.draft = true;
        }
    }
    visitFlag(ctx) {
        if (ctx.KW_MS()) {
            return Flag.MustSupport;
        }
        else if (ctx.KW_SU()) {
            return Flag.Summary;
        }
        else if (ctx.KW_MOD()) {
            return Flag.Modifier;
        }
        else if (ctx.KW_TU()) {
            return Flag.TrialUse;
        }
        else if (ctx.KW_NORMATIVE()) {
            return Flag.Normative;
        }
        else if (ctx.KW_DRAFT()) {
            return Flag.Draft;
        }
        return Flag.Unknown;
    }
    visitValueSetRule(ctx) {
        const vsRule = new rules_1.ValueSetRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        vsRule.valueSet = this.aliasAwareValue(ctx.SEQUENCE());
        vsRule.strength = ctx.strength() ? this.visitStrength(ctx.strength()) : 'required';
        vsRule.units = ctx.KW_UNITS() != null;
        return vsRule;
    }
    visitStrength(ctx) {
        if (ctx.KW_EXAMPLE()) {
            return 'example';
        }
        else if (ctx.KW_PREFERRED()) {
            return 'preferred';
        }
        else if (ctx.KW_EXTENSIBLE()) {
            return 'extensible';
        }
        return 'required';
    }
    visitFixedValueRule(ctx) {
        const fixedValueRule = new rules_1.FixedValueRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        fixedValueRule.fixedValue = this.visitValue(ctx.value());
        fixedValueRule.exactly = ctx.KW_EXACTLY() != null;
        fixedValueRule.units = ctx.KW_UNITS() != null;
        fixedValueRule.isResource = ctx.value().SEQUENCE() != null;
        return fixedValueRule;
    }
    visitValue(ctx) {
        if (ctx.SEQUENCE()) {
            return ctx.SEQUENCE().getText();
        }
        if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        if (ctx.MULTILINE_STRING()) {
            return this.extractMultilineString(ctx.MULTILINE_STRING());
        }
        if (ctx.NUMBER()) {
            return parseFloat(ctx.NUMBER().getText());
        }
        if (ctx.DATETIME()) {
            // for now, treat datetime like a string
            return ctx.DATETIME().getText();
        }
        if (ctx.TIME()) {
            // for now, treat datetime like a string
            return ctx.TIME().getText();
        }
        if (ctx.reference()) {
            return this.visitReference(ctx.reference());
        }
        if (ctx.code()) {
            return this.visitCode(ctx.code());
        }
        if (ctx.quantity()) {
            return this.visitQuantity(ctx.quantity());
        }
        if (ctx.ratio()) {
            return this.visitRatio(ctx.ratio());
        }
        if (ctx.bool()) {
            return this.visitBool(ctx.bool());
        }
    }
    visitCode(ctx) {
        const concept = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (ctx.STRING()) {
            concept.display = this.extractString(ctx.STRING());
        }
        return concept;
    }
    visitConcept(ctx) {
        const codePart = this.visitCode(ctx.code());
        const concept = new fshtypes_1.FshConcept(codePart.code, codePart.display)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (codePart.system) {
            FSHLogger_1.logger.error('Do not include the system when listing concepts for a code system.', concept.sourceInfo);
        }
        if (ctx.STRING()) {
            concept.definition = this.extractString(ctx.STRING());
        }
        return concept;
    }
    visitQuantity(ctx) {
        const value = parseFloat(ctx.NUMBER().getText());
        const delimitedUnit = ctx.UNIT().getText(); // e.g., 'mm'
        // the literal version of quantity always assumes UCUM code system
        const unit = new fshtypes_1.FshCode(delimitedUnit.slice(1, -1), 'http://unitsofmeasure.org')
            .withLocation(this.extractStartStop(ctx.UNIT()))
            .withFile(this.currentFile);
        const quantity = new fshtypes_1.FshQuantity(value, unit)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return quantity;
    }
    visitRatio(ctx) {
        const ratio = new fshtypes_1.FshRatio(this.visitRatioPart(ctx.ratioPart()[0]), this.visitRatioPart(ctx.ratioPart()[1]))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        return ratio;
    }
    visitRatioPart(ctx) {
        if (ctx.NUMBER()) {
            const quantity = new fshtypes_1.FshQuantity(parseFloat(ctx.NUMBER().getText()))
                .withLocation(this.extractStartStop(ctx.NUMBER()))
                .withFile(this.currentFile);
            return quantity;
        }
        return this.visitQuantity(ctx.quantity());
    }
    visitReference(ctx) {
        const ref = new fshtypes_1.FshReference(this.aliasAwareValue(ctx.REFERENCE(), this.parseReference(ctx.REFERENCE().getText())[0]))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        if (ctx.STRING()) {
            ref.display = this.extractString(ctx.STRING());
        }
        return ref;
    }
    parseReference(reference) {
        return reference.slice(reference.indexOf('(') + 1, reference.length - 1).split(/\s*\|\s*/);
    }
    visitBool(ctx) {
        return ctx.KW_TRUE() != null;
    }
    visitOnlyRule(ctx) {
        const onlyRule = new rules_1.OnlyRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        ctx.targetType().forEach(t => {
            if (t.reference()) {
                const references = this.parseReference(t
                    .reference()
                    .REFERENCE()
                    .getText());
                references.forEach(r => onlyRule.types.push({
                    type: this.aliasAwareValue(t.reference().REFERENCE(), r),
                    isReference: true
                }));
            }
            else {
                onlyRule.types.push({ type: this.aliasAwareValue(t.SEQUENCE()) });
            }
        });
        return onlyRule;
    }
    visitContainsRule(ctx) {
        const rules = [];
        const containsRule = new rules_1.ContainsRule(this.visitPath(ctx.path()))
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        rules.push(containsRule);
        ctx.item().forEach(i => {
            let item;
            if (i.KW_NAMED()) {
                item = {
                    type: this.aliasAwareValue(i.SEQUENCE()[0], i.SEQUENCE()[0].getText()),
                    name: i.SEQUENCE()[1].getText()
                };
            }
            else {
                item = {
                    name: i.SEQUENCE()[0].getText()
                };
            }
            containsRule.items.push(item);
            const cardRule = new rules_1.CardRule(`${containsRule.path}[${item.name}]`)
                .withLocation(this.extractStartStop(i))
                .withFile(this.currentFile);
            const card = this.parseCard(i.CARD().getText(), cardRule);
            cardRule.min = card.min;
            cardRule.max = card.max;
            rules.push(cardRule);
            if (i.flag() && i.flag().length > 0) {
                const flagRule = new rules_1.FlagRule(`${containsRule.path}[${item.name}]`)
                    .withLocation(this.extractStartStop(i))
                    .withFile(this.currentFile);
                this.parseFlags(flagRule, i.flag());
                rules.push(flagRule);
            }
        });
        return rules;
    }
    visitCaretValueRule(ctx) {
        const path = ctx.path() ? this.visitPath(ctx.path()) : '';
        const caretValueRule = new rules_1.CaretValueRule(path)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        // Get the caret path, but slice off the starting ^
        caretValueRule.caretPath = this.visitCaretPath(ctx.caretPath()).slice(1);
        caretValueRule.value = this.visitValue(ctx.value());
        return caretValueRule;
    }
    visitObeysRule(ctx) {
        const rules = [];
        const path = ctx.path() ? this.visitPath(ctx.path()) : '';
        ctx.SEQUENCE().forEach(invariant => {
            const obeysRule = new rules_1.ObeysRule(path)
                .withLocation(this.extractStartStop(ctx))
                .withFile(this.currentFile);
            obeysRule.invariant = invariant.getText();
            rules.push(obeysRule);
        });
        return rules;
    }
    visitMappingRule(ctx) {
        var _a;
        const path = ctx.path() ? this.visitPath(ctx.path()) : '';
        const mappingRule = new rules_1.MappingRule(path)
            .withLocation(this.extractStartStop(ctx))
            .withFile(this.currentFile);
        mappingRule.map = this.extractString(ctx.STRING()[0]);
        if (ctx.STRING().length > 1) {
            mappingRule.comment = this.extractString(ctx.STRING()[1]);
        }
        if (ctx.CODE()) {
            mappingRule.language = this.parseCodeLexeme(ctx.CODE().getText(), ctx.CODE())
                .withLocation(this.extractStartStop(ctx.CODE()))
                .withFile(this.currentFile);
            if (((_a = mappingRule.language.system) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                FSHLogger_1.logger.warn('Do not specify a system for mapping language.', mappingRule.language.sourceInfo);
            }
        }
        return mappingRule;
    }
    visitVsComponent(ctx) {
        const inclusion = ctx.KW_EXCLUDE() == null;
        let vsComponent;
        if (ctx.vsConceptComponent()) {
            vsComponent = new fshtypes_1.ValueSetConceptComponent(inclusion);
            [vsComponent.concepts, vsComponent.from] = this.visitVsConceptComponent(ctx.vsConceptComponent());
        }
        else if (ctx.vsFilterComponent()) {
            vsComponent = new fshtypes_1.ValueSetFilterComponent(inclusion);
            [vsComponent.filters, vsComponent.from] = this.visitVsFilterComponent(ctx.vsFilterComponent());
        }
        return vsComponent;
    }
    visitVsConceptComponent(ctx) {
        const concepts = [];
        const from = ctx.vsComponentFrom()
            ? this.visitVsComponentFrom(ctx.vsComponentFrom())
            : {};
        if (ctx.code()) {
            const singleCode = this.visitCode(ctx.code());
            if (singleCode.system && from.system) {
                FSHLogger_1.logger.error(`Concept ${singleCode.code} specifies system multiple times`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
            else if (singleCode.system) {
                from.system = singleCode.system;
                concepts.push(singleCode);
            }
            else if (from.system) {
                singleCode.system = from.system;
                concepts.push(singleCode);
            }
            else {
                FSHLogger_1.logger.error(`Concept ${singleCode.code} must include system as "SYSTEM#CONCEPT" or "#CONCEPT from system SYSTEM"`, {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        else if (ctx.COMMA_DELIMITED_CODES()) {
            if (from.system) {
                const codes = ctx
                    .COMMA_DELIMITED_CODES()
                    .getText()
                    .split(/\s*,\s+#/);
                codes[0] = codes[0].slice(1);
                const location = this.extractStartStop(ctx.COMMA_DELIMITED_CODES());
                codes.forEach(code => {
                    var _a;
                    let codePart, description;
                    if (code.charAt(0) == '"') {
                        // codePart is a quoted string, just like description (if present).
                        [codePart, description] = code
                            .match(/"([^\s\\"]|\\"|\\\\)+(\s([^\s\\"]|\\"|\\\\)+)*"/g)
                            .map(quotedString => quotedString.slice(1, -1));
                    }
                    else {
                        // codePart is not a quoted string.
                        // if there is a description after the code,
                        // it will be separated by whitespace before the leading "
                        const codeEnd = (_a = code.match(/\s+"/)) === null || _a === void 0 ? void 0 : _a.index;
                        if (codeEnd) {
                            codePart = code.slice(0, codeEnd);
                            description = code
                                .slice(codeEnd)
                                .trim()
                                .slice(1, -1);
                        }
                        else {
                            codePart = code.trim();
                        }
                    }
                    concepts.push(new fshtypes_1.FshCode(codePart, from.system, description)
                        .withLocation(location)
                        .withFile(this.currentFile));
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when listing concepts in a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        return [concepts, from];
    }
    visitVsFilterComponent(ctx) {
        const filters = [];
        const from = ctx.vsComponentFrom()
            ? this.visitVsComponentFrom(ctx.vsComponentFrom())
            : {};
        if (ctx.vsFilterList()) {
            if (from.system) {
                ctx
                    .vsFilterList()
                    .vsFilterDefinition()
                    .forEach(filterDefinition => {
                    try {
                        filters.push(this.visitVsFilterDefinition(filterDefinition));
                    }
                    catch (e) {
                        FSHLogger_1.logger.error(e, {
                            location: this.extractStartStop(filterDefinition),
                            file: this.currentFile
                        });
                    }
                });
            }
            else {
                FSHLogger_1.logger.error('System is required when filtering a value set component', {
                    file: this.currentFile,
                    location: this.extractStartStop(ctx)
                });
            }
        }
        return [filters, from];
    }
    visitVsComponentFrom(ctx) {
        const from = {};
        if (ctx.vsFromSystem()) {
            from.system = this.aliasAwareValue(ctx.vsFromSystem().SEQUENCE());
        }
        if (ctx.vsFromValueset()) {
            if (ctx.vsFromValueset().SEQUENCE()) {
                from.valueSets = [this.aliasAwareValue(ctx.vsFromValueset().SEQUENCE())];
            }
            else if (ctx.vsFromValueset().COMMA_DELIMITED_SEQUENCES()) {
                from.valueSets = ctx
                    .vsFromValueset()
                    .COMMA_DELIMITED_SEQUENCES()
                    .getText()
                    .split(/\s*,\s*/)
                    .map(fromVs => this.aliasAwareValue(ctx.vsFromValueset().COMMA_DELIMITED_SEQUENCES(), fromVs.trim()));
            }
        }
        return from;
    }
    /**
     * The replace makes FSH permissive in regards to the official specifications,
     * which spells operator "descendant-of" as "descendent-of".
     * @see {@link http://hl7.org/fhir/valueset-filter-operator.html}
     */
    visitVsFilterDefinition(ctx) {
        const property = ctx.SEQUENCE().getText();
        const operator = ctx
            .vsFilterOperator()
            .getText()
            .toLocaleLowerCase()
            .replace('descendant', 'descendent');
        if (ctx.vsFilterValue() == null && operator !== fshtypes_1.VsOperator.EXISTS) {
            throw new errors_1.ValueSetFilterMissingValueError(operator);
        }
        const value = ctx.vsFilterValue() ? this.visitVsFilterValue(ctx.vsFilterValue()) : true;
        switch (operator) {
            case fshtypes_1.VsOperator.EQUALS:
            case fshtypes_1.VsOperator.IN:
            case fshtypes_1.VsOperator.NOT_IN:
                if (typeof value !== 'string') {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'string');
                }
                break;
            case fshtypes_1.VsOperator.IS_A:
            case fshtypes_1.VsOperator.DESCENDENT_OF:
            case fshtypes_1.VsOperator.IS_NOT_A:
            case fshtypes_1.VsOperator.GENERALIZES:
                if (!(value instanceof fshtypes_1.FshCode)) {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'code');
                }
                break;
            case fshtypes_1.VsOperator.REGEX:
                if (!(value instanceof RegExp)) {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'regex');
                }
                break;
            case fshtypes_1.VsOperator.EXISTS:
                if (typeof value !== 'boolean') {
                    throw new errors_1.ValueSetFilterValueTypeError(operator, 'boolean');
                }
                break;
            default:
                throw new errors_1.ValueSetFilterOperatorError(ctx.vsFilterOperator().getText());
        }
        return {
            property: property,
            operator: operator,
            value: value
        };
    }
    visitVsFilterValue(ctx) {
        if (ctx.code()) {
            return this.visitCode(ctx.code());
        }
        else if (ctx.REGEX()) {
            return RegExp(ctx
                .REGEX()
                .getText()
                .slice(1, -1));
        }
        else if (ctx.STRING()) {
            return this.extractString(ctx.STRING());
        }
        else if (ctx.KW_TRUE()) {
            return true;
        }
        else if (ctx.KW_FALSE()) {
            return false;
        }
    }
    validateAliasResolves(parentCtx, value = parentCtx.getText()) {
        const hasAlias = this.allAliases.has(value);
        if (!hasAlias && value.startsWith('$')) {
            FSHLogger_1.logger.error(`Value ${value} does not resolve as alias, values beginning with "$" must resolve`, { location: this.extractStartStop(parentCtx), file: this.currentFile });
        }
    }
    aliasAwareValue(parentCtx, value = parentCtx.getText()) {
        this.validateAliasResolves(parentCtx, value);
        return this.allAliases.has(value) ? this.allAliases.get(value) : value;
    }
    extractString(stringCtx) {
        const str = stringCtx.getText();
        return str
            .slice(1, str.length - 1)
            .replace(/\\\\/g, '\\')
            .replace(/\\"/g, '"');
    }
    /**
     * Multiline strings receive special handling:
     * - if the first line contains only whitespace (including newline), toss it
     * - if the last line contains only whitespace (including newline), toss it
     * - if another line contains only whitespace, truncate it
     * - for all other non-whitespace lines, detect the shortest number of leading spaces and always trim that off;
     *   this allows authors to indent a whole block of text, but not have it indented in the output.
     */
    extractMultilineString(mlStringCtx) {
        let mlstr = mlStringCtx.getText();
        // remove leading/trailing """
        mlstr = mlstr.slice(3, -3);
        // split into lines so we can process them to determine what leading spaces to trim
        let lines = mlstr.split(/\r?\n/);
        // if the first line is only whitespace, remove it
        if (lines[0].search(/\S/) === -1) {
            lines.shift();
        }
        // if the last line is only whitespace, remove it
        if (lines.length > 0 && lines[lines.length - 1].search(/\S/) === -1) {
            lines.pop();
        }
        lines = lines.map(l => (/^\s*$/.test(l) ? '' : l));
        // find the minimum number of spaces before the first char (ignore zero-length lines)
        let minSpaces = 0;
        lines.forEach(line => {
            const firstNonSpace = line.search(/\S|$/);
            const lineIsEmpty = /^$/.test(line);
            if (!lineIsEmpty && firstNonSpace >= 0 && (minSpaces === 0 || firstNonSpace < minSpaces)) {
                minSpaces = firstNonSpace;
            }
        });
        // consistently remove the common leading spaces and join the lines back together
        return lines.map(l => (l.length >= minSpaces ? l.slice(minSpaces) : l)).join('\n');
    }
    extractStartStop(ctx) {
        if (ctx instanceof Tree_1.TerminalNode) {
            return {
                startLine: ctx.symbol.line,
                startColumn: ctx.symbol.column + 1,
                endLine: ctx.symbol.line,
                endColumn: ctx.symbol.stop - ctx.symbol.start + ctx.symbol.column + 1
            };
        }
        else {
            return {
                startLine: ctx.start.line,
                startColumn: ctx.start.column + 1,
                endLine: ctx.stop.line,
                endColumn: ctx.stop.stop - ctx.stop.start + ctx.stop.column + 1
            };
        }
    }
    // NOTE: Since the ANTLR parser/lexer is JS (not typescript), we need to use some ts-ignore here.
    parseDoc(input, file) {
        const chars = new antlr4_1.InputStream(input);
        const lexer = new FSHLexer_1.FSHLexer(chars);
        const listener = new FSHErrorListener_1.FSHErrorListener(file);
        // @ts-ignore
        lexer.removeErrorListeners();
        // @ts-ignore
        lexer.addErrorListener(listener);
        // @ts-ignore
        const tokens = new antlr4_1.CommonTokenStream(lexer);
        const parser = new FSHParser_1.FSHParser(tokens);
        // @ts-ignore
        parser.removeErrorListeners();
        // @ts-ignore
        parser.addErrorListener(listener);
        // @ts-ignore
        parser.buildParseTrees = true;
        // @ts-ignore
        return parser.doc();
    }
}
exports.FSHImporter = FSHImporter;
//# sourceMappingURL=FSHImporter.js.map