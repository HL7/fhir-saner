"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Fishable_1 = require("../utils/Fishable");
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
class FHIRDefinitions {
    constructor() {
        this.packages = [];
        this.resources = new Map();
        this.profiles = new Map();
        this.extensions = new Map();
        this.types = new Map();
        this.valueSets = new Map();
        this.codeSystems = new Map();
        this.implementationGuides = new Map();
    }
    size() {
        return (this.resources.size +
            this.profiles.size +
            this.extensions.size +
            this.types.size +
            this.valueSets.size +
            this.codeSystems.size +
            this.implementationGuides.size);
    }
    // NOTE: These all return clones of the JSON to prevent the source values from being overwritten
    allResources() {
        return cloneJsonMapValues(this.resources);
    }
    allProfiles() {
        return cloneJsonMapValues(this.profiles);
    }
    allExtensions() {
        return cloneJsonMapValues(this.extensions);
    }
    allTypes() {
        return cloneJsonMapValues(this.types);
    }
    allValueSets() {
        return cloneJsonMapValues(this.valueSets);
    }
    allCodeSystems() {
        return cloneJsonMapValues(this.codeSystems);
    }
    allImplementationGuides() {
        return cloneJsonMapValues(this.implementationGuides);
    }
    add(definition) {
        if (definition.resourceType === 'StructureDefinition') {
            if (definition.type === 'Extension' &&
                definition.baseDefinition !== 'http://hl7.org/fhir/StructureDefinition/Element') {
                addDefinitionToMap(definition, this.extensions);
            }
            else if (definition.kind === 'primitive-type' ||
                definition.kind === 'complex-type' ||
                definition.kind === 'datatype') {
                addDefinitionToMap(definition, this.types);
            }
            else if (definition.kind === 'resource') {
                if (definition.derivation === 'constraint') {
                    addDefinitionToMap(definition, this.profiles);
                }
                else {
                    addDefinitionToMap(definition, this.resources);
                }
            }
        }
        else if (definition.resourceType === 'ValueSet') {
            addDefinitionToMap(definition, this.valueSets);
        }
        else if (definition.resourceType === 'CodeSystem') {
            addDefinitionToMap(definition, this.codeSystems);
        }
        else if (definition.resourceType === 'ImplementationGuide') {
            addDefinitionToMap(definition, this.implementationGuides);
        }
    }
    fishForFHIR(item, ...types) {
        // No types passed in means to search ALL supported types
        if (types.length === 0) {
            types = [
                Fishable_1.Type.Resource,
                Fishable_1.Type.Type,
                Fishable_1.Type.Profile,
                Fishable_1.Type.Extension,
                Fishable_1.Type.ValueSet,
                Fishable_1.Type.CodeSystem
            ];
        }
        for (const type of types) {
            let def;
            switch (type) {
                case Fishable_1.Type.Resource:
                    def = cloneDeep_1.default(this.resources.get(item));
                    break;
                case Fishable_1.Type.Type:
                    def = cloneDeep_1.default(this.types.get(item));
                    break;
                case Fishable_1.Type.Profile:
                    def = cloneDeep_1.default(this.profiles.get(item));
                    break;
                case Fishable_1.Type.Extension:
                    def = cloneDeep_1.default(this.extensions.get(item));
                    break;
                case Fishable_1.Type.ValueSet:
                    def = cloneDeep_1.default(this.valueSets.get(item));
                    break;
                case Fishable_1.Type.CodeSystem:
                    def = cloneDeep_1.default(this.codeSystems.get(item));
                    break;
                case Fishable_1.Type.Instance: // don't support resolving to FHIR examples
                default:
                    break;
            }
            if (def) {
                return def;
            }
        }
    }
    fishForMetadata(item, ...types) {
        const result = this.fishForFHIR(item, ...types);
        if (result) {
            return {
                id: result.id,
                name: result.name,
                sdType: result.type,
                url: result.url,
                parent: result.baseDefinition
            };
        }
    }
}
exports.FHIRDefinitions = FHIRDefinitions;
function addDefinitionToMap(def, defMap) {
    if (def.id) {
        defMap.set(def.id, def);
    }
    if (def.url) {
        defMap.set(def.url, def);
    }
    if (def.name) {
        defMap.set(def.name, def);
    }
}
function cloneJsonMapValues(map) {
    return Array.from(map.values()).map(v => cloneDeep_1.default(v));
}
//# sourceMappingURL=FHIRDefinitions.js.map