"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const import_1 = require("../import");
const FSHLogger_1 = require("./FSHLogger");
/**
 * The MasterFisher can fish from the tank, the FHIR definitions, and the package that is currently
 * being exported. When the MasterFisher fishes, it fishes in the package first, then the tank, and
 * then the FHIRDefinitions.  This essentially prefers local definitions first (when there are naming
 * clashes).
 *
 * The MasterFisher also uses its knowledge of these Fishable locations to do some necessary magic.
 * For instance, the FSHTank has no knowledge of FHIRDefinitions, so it cannot provide the correct
 * sdType for its metadata results.  When the MasterFisher detects this has happened, it uses the
 * other Fishable locations to determine the proper sdType (even for an item that currently exists
 * only in the tank).
 */
class MasterFisher {
    constructor(tank, fhir, pkg) {
        this.tank = tank;
        this.fhir = fhir;
        this.pkg = pkg;
    }
    /**
     * Searches for the FHIR JSON by name/id/url.  It will first search through the local package
     * (which contains FHIR artifacts exported so far), then through the external FHIR definitions.
     * @param {string} item - the item name/id/url to fish for
     * @param types - the allowable types to fish for
     */
    fishForFHIR(item, ...types) {
        var _a, _b, _c, _d, _e;
        // Resolve the alias if necessary
        item = (_b = (_a = this.tank) === null || _a === void 0 ? void 0 : _a.resolveAlias(item), (_b !== null && _b !== void 0 ? _b : item));
        // First check for it in the package
        let result = (_c = this.pkg) === null || _c === void 0 ? void 0 : _c.fishForFHIR(item, ...types);
        if (result == null) {
            // If it is in the tank, return undefined. We don't want to return the external FHIR
            // definition, even if it exists -- because it won't match what is in the tank.  This
            // ensures consistency between the outputs of fishForFHIR and fishForMetadata.
            if ((_d = this.tank) === null || _d === void 0 ? void 0 : _d.fish(item, ...types)) {
                return;
            }
            result = (_e = this.fhir) === null || _e === void 0 ? void 0 : _e.fishForFHIR(item, ...types);
        }
        return result;
    }
    /**
     * Searches for the Metadata associated with the passed in name/id/url.  It will first search
     * through the local package (which contains FHIR artifacts exported so far), then through the
     * tank, then through the external FHIR definitions. This function is useful because it gets
     * commonly used information without having to force an export. This helps to reduce the risk
     * of circular dependencies causing problems.
     * @param item - the item/name/id url to fish for
     * @param types - the allowable types to fish for
     */
    fishForMetadata(item, ...types) {
        var _a, _b;
        // Resolve the alias if necessary
        item = (_b = (_a = this.tank) === null || _a === void 0 ? void 0 : _a.resolveAlias(item), (_b !== null && _b !== void 0 ? _b : item));
        const fishables = [this.pkg, this.tank, this.fhir].filter(f => f != null);
        for (const fishable of fishables) {
            const result = fishable.fishForMetadata(item, ...types);
            if (result) {
                // If it came from the tank, we need to get the sdType because the tank doesn't know.
                if (fishable instanceof import_1.FSHTank) {
                    result.sdType = this.findSdType(result, types, fishables);
                }
                return result;
            }
        }
    }
    findSdType(meta, types, fishables) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const history = [meta];
        let [sdType, parent] = [meta.sdType, meta.parent];
        while (sdType == null && parent != null) {
            // Resolve the alias if necessary
            parent = (_b = (_a = this.tank) === null || _a === void 0 ? void 0 : _a.resolveAlias(parent), (_b !== null && _b !== void 0 ? _b : parent));
            let parentResult;
            for (const fishable of fishables) {
                parentResult = fishable.fishForMetadata(parent, ...types);
                if (parentResult != null) {
                    if (history.some(md => md.url === parentResult.url)) {
                        let message = 'Circular dependency detected on parent relationships: ' +
                            [...history, parentResult].map(l => l.name).join(' < ');
                        const fhirMeta = (_d = (_c = this.fhir) === null || _c === void 0 ? void 0 : _c.fishForMetadata(parentResult.name), (_d !== null && _d !== void 0 ? _d : (_e = this.fhir) === null || _e === void 0 ? void 0 : _e.fishForMetadata(parentResult.id)));
                        if (fhirMeta) {
                            message += `\n  If the parent ${parentResult.name} is intended to refer to the FHIR resource, use its URL: ${fhirMeta.url}`;
                        }
                        FSHLogger_1.logger.error(message, fishable instanceof import_1.FSHTank ? (_f = fishable.fish(parent)) === null || _f === void 0 ? void 0 : _f.sourceInfo : undefined);
                        return;
                    }
                    history.push(parentResult);
                    break; // break out of fishables loop
                }
            }
            [sdType, parent] = [(_g = parentResult) === null || _g === void 0 ? void 0 : _g.sdType, (_h = parentResult) === null || _h === void 0 ? void 0 : _h.parent];
        }
        return sdType;
    }
}
exports.MasterFisher = MasterFisher;
//# sourceMappingURL=MasterFisher.js.map