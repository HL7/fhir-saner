import { Fishable, Type, Metadata } from './Fishable';
import { FSHTank } from '../import';
import { FHIRDefinitions } from '../fhirdefs';
import { Package } from '../export';
/**
 * The MasterFisher can fish from the tank, the FHIR definitions, and the package that is currently
 * being exported. When the MasterFisher fishes, it fishes in the package first, then the tank, and
 * then the FHIRDefinitions.  This essentially prefers local definitions first (when there are naming
 * clashes).
 *
 * The MasterFisher also uses its knowledge of these Fishable locations to do some necessary magic.
 * For instance, the FSHTank has no knowledge of FHIRDefinitions, so it cannot provide the correct
 * sdType for its metadata results.  When the MasterFisher detects this has happened, it uses the
 * other Fishable locations to determine the proper sdType (even for an item that currently exists
 * only in the tank).
 */
export declare class MasterFisher implements Fishable {
    tank?: FSHTank;
    fhir?: FHIRDefinitions;
    pkg?: Package;
    constructor(tank?: FSHTank, fhir?: FHIRDefinitions, pkg?: Package);
    /**
     * Searches for the FHIR JSON by name/id/url.  It will first search through the local package
     * (which contains FHIR artifacts exported so far), then through the external FHIR definitions.
     * @param {string} item - the item name/id/url to fish for
     * @param types - the allowable types to fish for
     */
    fishForFHIR(item: string, ...types: Type[]): any | undefined;
    /**
     * Searches for the Metadata associated with the passed in name/id/url.  It will first search
     * through the local package (which contains FHIR artifacts exported so far), then through the
     * tank, then through the external FHIR definitions. This function is useful because it gets
     * commonly used information without having to force an export. This helps to reduce the risk
     * of circular dependencies causing problems.
     * @param item - the item/name/id url to fish for
     * @param types - the allowable types to fish for
     */
    fishForMetadata(item: string, ...types: Type[]): Metadata;
    private findSdType;
}
